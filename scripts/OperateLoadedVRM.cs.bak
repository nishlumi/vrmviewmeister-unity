using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using UnityEngine;
using UserHandleSpace;
using RootMotion.FinalIK;
using VRM;
using DG.Tweening;


namespace UserHandleSpace
{
    /// <summary>
    /// Attach for VRM game object
    /// </summary>
    public class OperateLoadedVRM : OperateLoadedBase
    {

        [DllImport("__Internal")]
        private static extern void ReceiveStringVal(string val);
        [DllImport("__Internal")]
        private static extern void ReceiveIntVal(int val);
        [DllImport("__Internal")]
        private static extern void ReceiveFloatVal(float val);



        /**
         *  This class is manager function, all VRM
         *  Variables only...
         */
        //public GameObject relatedHandleParent;
        private VRMImporterContext context;
        private Bounds bodyInfoTPose;
        private List<Vector3> bodyinfoList;
        private SkinnedMeshRenderer BSFace;

        public List<BasicStringFloatList> blendShapeList;
        public List<VRMGravityInfo> gravityList;

        public bool isMoveMode;

        public int equipType; //Flag for animation: -1 - unequip, 0 - no change, 1 - to equip
        public AvatarEquipmentClass equipDestinations;
        public AvatarGravityClass gravityList;


        private ManageAnimation manim;

        //private float[] bodyInfoFloat;
        /*
        private bool isFixMoving;

        private Vector3 oldPosition;
        private Quaternion oldRotation;
        private Vector3 defaultPosition;
        private Quaternion defaultRotation;
        private Vector3 defaultColliderPosition;

        private Vector3 oldikposition;
        */

        // Start is called before the first frame update
        private void Awake()
        {
            SaveDefaultTransform(true, true);
            SetActiveFace();

            targetType = AF_TARGETTYPE.VRM;

            bodyinfoList = new List<Vector3>();
            blendShapeList = new List<BasicStringFloatList>();
            gravityList = new AvatarGravityClass();
            equipType = 0;
            equipDestinations = new AvatarEquipmentClass();
        }
        void Start()
        {
            manim = GameObject.Find("AnimateArea").GetComponent<ManageAnimation>();

            blendShapeList.Clear();
            List<string> lst = ListAvatarBlendShape();
            lst.ForEach(item =>
            {
                string[] arr = item.Split('=');
                float value = -1f; // float.TryParse(arr[1], out value) ? value : -1f;
                BasicStringFloatList lsf = new BasicStringFloatList(arr[0], value);
                blendShapeList.Add(lsf);

            });
        }

        // Update is called once per frame
        void Update()
        {
            //--if move ik handle parent, move CapsuleCollider of active avatar to same position.
            //GameObject ikhp = GameObject.Find("IKHandleParent");
            //OperateActiveVRM oavrm;
            //if (ikhp.TryGetComponent<OperateActiveVRM>(out oavrm))
            //{
            if (relatedHandleParent)
            {
                Transform iktran = relatedHandleParent.transform;
                if (iktran.position != oldikposition)
                {
                    CapsuleCollider cap = GetComponent<CapsuleCollider>();
                    cap.center = new Vector3(iktran.position.x, iktran.position.y + (defaultColliderPosition.y), iktran.position.z);

                    oldikposition = iktran.position;
                }

            }
            //}


        }
        private void LateUpdate()
        {

        }
        public VRMImporterContext GetContext()
        {
            return context;
        }
        public void SetContext(VRMImporterContext cont)
        {
            context = cont;
        }
        public Bounds GetTPoseBodyInfo()
        {
            return bodyInfoTPose;
        }
        public void SetTPoseBodyInfo(Bounds pose)
        {
            bodyInfoTPose = new Bounds(pose.center, pose.size);
            bodyInfoTPose.extents = new Vector3(pose.extents.x, pose.extents.y, pose.extents.z);

            //Array.Copy(basebodyInfo, bodyInfoFloat, basebodyInfo.Length);
        }
        public List<Vector3> GetTPoseBodyList(bool iscopy = false)
        {
            if (iscopy)
            {
                List<Vector3> lst = new List<Vector3>();
                for (int i = 0; i < bodyinfoList.Count; i++)
                {
                    lst.Add(new Vector3(  bodyinfoList[i].x, bodyinfoList[i].y, bodyinfoList[i].z ));
                }
                return lst;
            }
            else
            {
                return bodyinfoList;
            }
        }
        public void SetTPoseBodyList(List<Vector3> lst)
        {
            bodyinfoList.Clear();
            for (int i = 0; i < lst.Count; i++)
            {
                bodyinfoList.Add(new Vector3(lst[i].x, lst[i].y, lst[i].z));
            }
        }
        public override void SetEnableWholeIK(int intflag)
        {
            bool flag = intflag == 1 ? true : false;

            BipedIK bik = transform.GetComponent<BipedIK>();
            CCDIK cik = transform.GetComponent<CCDIK>();

            if (bik != null) bik.enabled = flag;
            if (cik != null) cik.enabled = flag;
        }
        public override void SetFixMoving(bool flag)
        {
            isFixMoving = flag;
            if (flag)
            {
                transform.gameObject.GetComponent<CapsuleCollider>().enabled = false;
                relatedHandleParent.SetActive(false);
            }
            else
            {
                transform.gameObject.GetComponent<CapsuleCollider>().enabled = true;
                relatedHandleParent.SetActive(true);
            }
        }

        public override void SetScale(string param)
        {
            string[] prm = param.Split(',');
            float x = float.TryParse(prm[0], out x) ? x : 0f;
            float y = float.TryParse(prm[1], out y) ? y : 0f;
            float z = float.TryParse(prm[2], out z) ? z : 0f;

            //---Different to OperateActiveVRM.SetScale:
            // OperateActiveVRM: base point is child object with collider. refer to transform.parent.
            // At here: transform.gameObject IS Other Object own.
            transform.DOScale(new Vector3(x, y, z), 0.2f);

        }
        public GameObject GetIKHandle(string name)
        {
            GameObject ret = null;

            int cnt = relatedHandleParent.transform.childCount;
            for (int i = 0; i < cnt; i++)
            {
                if (relatedHandleParent.transform.GetChild(i).name == name)
                {
                    ret = relatedHandleParent.transform.GetChild(i).gameObject;
                    break;
                }
            }
            return ret;
        }

        /// <summary>
        /// Initial enumrate Gravity information
        /// </summary>
        public void ListGravityInfo()
        {
            VRMSpringBone[] bones = transform.GetComponentsInChildren<VRMSpringBone>();
            gravityList.list.Clear();
            for (int i = 0; i < bones.Length; i++)
            {
                VRMGravityInfo vgi = new VRMGravityInfo();
                vgi.comment = bones[i].m_comment;
                if (bones[i].RootBones.Count > 0) vgi.rootBoneName = bones[i].RootBones[0].gameObject.name;
                vgi.power = bones[i].m_gravityPower;
                vgi.dir.x = bones[i].m_gravityDir.x;
                vgi.dir.y = bones[i].m_gravityDir.y;
                vgi.dir.z = bones[i].m_gravityDir.z;
                gravityList.list.Add(vgi);
            }
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="param">csv-string: 0 - comment, 1 - root bone[0] name</param>
        /// <returns></returns>
        public VRMGravityInfo GetGravityInfo(string param)
        {
            VRMGravityInfo ret = new VRMGravityInfo();

            string[] arr = param.Split(',');

            VRMSpringBone[] bones = transform.GetComponentsInChildren<VRMSpringBone>();
            for (int i = 0; i < bones.Length; i++)
            {
                if ((bones[i].m_comment == arr[0]) && (bones[i].RootBones[0].gameObject.name == arr[1]))
                {
                    ret.comment = bones[i].m_comment;
                    if (bones[i].RootBones.Count > 0) ret.rootBoneName = bones[i].RootBones[0].gameObject.name;
                    ret.power = bones[i].m_gravityPower;
                    ret.dir.x = bones[i].m_gravityDir.x;
                    ret.dir.y = bones[i].m_gravityDir.y;
                    ret.dir.z = bones[i].m_gravityDir.z;
                }
            }

            return ret;
        }
        public void GetGravityInfoFromOuter(string param)
        {
            VRMGravityInfo ret = GetGravityInfo(param);
            string js = JsonUtility.ToJson(ret);
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveStringVal(js);
#endif

        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="param">csv-string: 0 - comment, 1 - root bone[0] name, 2 - power</param>
        public void SetGravityPower(string param)
        {
            VRMGravityInfo ret = new VRMGravityInfo();

            string[] arr = param.Split(',');
            if (arr.Length > 2)
            {
                float val = float.TryParse(arr[2], out val) ? val : 0f;

                VRMSpringBone[] bones = transform.GetComponentsInChildren<VRMSpringBone>();
                for (int i = 0; i < bones.Length; i++)
                {
                    if ((bones[i].m_comment == arr[0]) && (bones[i].RootBones[0].gameObject.name == arr[1]))
                    {
                        bones[i].m_gravityPower = val;
                        break;
                    }
                }
            }
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="param">csv-string: 0 - comment, 1 - root bone[0] name, 2 - x, 3 - y, 4 - z</param>
        public void SetGravityDir(string param)
        {
            VRMGravityInfo ret = new VRMGravityInfo();

            string[] arr = param.Split(',');
            if (arr.Length > 5)
            {
                float x = float.TryParse(arr[2], out x) ? x : 0f;
                float y = float.TryParse(arr[3], out x) ? x : 0f;
                float z = float.TryParse(arr[4], out x) ? x : 0f;

                VRMSpringBone[] bones = transform.GetComponentsInChildren<VRMSpringBone>();
                for (int i = 0; i < bones.Length; i++)
                {
                    if ((bones[i].m_comment == arr[0]) && (bones[i].RootBones[0].gameObject.name == arr[1]))
                    {
                        bones[i].m_gravityDir.x = x;
                        bones[i].m_gravityDir.y = y;
                        bones[i].m_gravityDir.z = z;
                        break;
                    }
                }
            }

        }

        /// <summary>
        /// To pack all properties for HTML-UI
        /// </summary>
        public void GetIndicatedPropertyFromOuter()
        {
            string ret = "";

            LeftHandPoseController ctl = GetComponent<LeftHandPoseController>();
            RightHandPoseController ctr = GetComponent<RightHandPoseController>();

            List<string> lst = ListAvatarBlendShape();
            string blendshape = string.Join(",", lst.ToArray());
            int eflag = GetEquipFlag();
            string js = JsonUtility.ToJson(equipDestinations);
            string grajs = JsonUtility.ToJson(gravityList);

            ret = "l," + ctl.currentPose.ToString() + "," + ctl.handPoseValue.ToString()
                + "%" +
                "r," + ctr.currentPose.ToString() + "," + ctr.handPoseValue.ToString()
                + "\t" + 
                blendshape
                + "\t" + 
                eflag
                + "\t" + 
                js
                + "\t" + 
                grajs
            ;
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveStringVal(ret);
#endif
        }
        //===============================================================================================================***
        //  Hand Pose
        public string ListHandPose()
        {
            string ret = "";
            string[] arms = new string[2];
            LeftHandPoseController ctl = GetComponent<LeftHandPoseController>();
            RightHandPoseController ctr = GetComponent<RightHandPoseController>();
            
            ret = "l," + ctl.currentPose.ToString() + "," + ctl.handPoseValue.ToString()// + "," + ctl.handPose2Value.ToString() + "," + ctl.handPose3Value.ToString() + "," + ctl.handPose4Value.ToString() + "," + ctl.handPose5Value.ToString() + "," + ctl.handPose6Value.ToString()
                + "%" +
                "r," + ctr.currentPose.ToString() + "," + ctr.handPoseValue.ToString()// + "," + ctr.handPose2Value.ToString() + "," + ctr.handPose3Value.ToString() + "," + ctr.handPose4Value.ToString() + "," + ctr.handPose5Value.ToString() + "," + ctr.handPose6Value.ToString();
            ;
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveStringVal(ret);
#endif
            return ret;
        }
        /// <summary>
        /// Change Hand Pose
        /// </summary>
        /// <param name="param">CSV-string : 0 = r(right), l(left), 1 = pose type(1-6), 2 = pose weight</param>
        public void PosingHandFromOuter(string param)
        {

            string[] prm = param.Split(',');
            string handtype = prm[0];
            int posetype = int.TryParse(prm[1], out posetype) ? posetype : 1;
            float value = float.TryParse(prm[2], out value) ? value : 0f;
            //Debug.Log("unity . int=" + posetype);
            //Debug.Log("unity . float=" + value);

            LeftHandPoseController ctl = GetComponent<LeftHandPoseController>();
            RightHandPoseController ctr = GetComponent<RightHandPoseController>();

            if (handtype == "l")
            {
                ctl.ResetPose();
                ctl.SetPose(posetype, value);
            }
            else
            {
                ctr.ResetPose();
                ctr.SetPose(posetype, value);
            }
        }


        //===============================================================================================================================
        //  Blend Shape 
        public SkinnedMeshRenderer GetBlendShapeTarget()
        {
            return BSFace;
        }
        public SkinnedMeshRenderer SetActiveFace()
        {
            int cnt = transform.childCount;
            SkinnedMeshRenderer mesh = null;
            for (int i = 0; i < cnt; i++)
            {
                mesh = transform.GetChild(i).GetComponent<SkinnedMeshRenderer>();
                if (mesh != null)
                {
                    if (mesh.sharedMesh.blendShapeCount > 0)
                    {
                        BSFace = mesh;
                        break;
                    }
                }

            }
            return mesh;
        }
        /// <summary>
        /// Get all blend shapes, the avatar has.
        /// </summary>
        /// <returns>List string Blend shape lis</returns>
        public List<string> ListAvatarBlendShape()
        {
            List<string> ret = new List<string>();
            if (BSFace)
            {
                int bscnt = BSFace.sharedMesh.blendShapeCount;
                for (int i = 0; i < bscnt; i++)
                {
                    ret.Add(BSFace.sharedMesh.GetBlendShapeName(i) + "=" + BSFace.GetBlendShapeWeight(i));
                }
            }

            return ret;
        }
        /// <summary>
        /// Get all blend shapes, the avatar has. When user call from HTML
        /// </summary>
        /// <returns>string Blend shape list</returns>
        public string ListAvatarBlendShapeFromOuter()
        {
            List<string> lst = ListAvatarBlendShape();
            string ret = string.Join(",", lst.ToArray());
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveStringVal(ret);
#endif
            return ret;
        }
        public void InitializeBlendShapeList()
        {
            blendShapeList.Clear();
            List<string> lst = ListAvatarBlendShape();
            lst.ForEach(item =>
            {
                string[] arr = item.Split('=');
                float value = -1f; // float.TryParse(arr[1], out value) ? value : -1f;
                BasicStringFloatList lsf = new BasicStringFloatList(arr[0], value);
                blendShapeList.Add(lsf);

            });
        }
        public float getAvatarBlendShape(string param)
        {
            float ret = 0f;
            List<string> lst = ListAvatarBlendShape();
            for (int i = 0; i < lst.Count; i++)
            {
                if (lst[i].IndexOf(param) > -1)
                {
                    ret = BSFace.GetBlendShapeWeight(i);
                    break;
                }
            }
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveFloatVal(ret);
#endif
            return ret;
        }
        public float getAvatarBlendShapeValue(string param)
        {
            float ret = 0f;
            List<string> lst = ListAvatarBlendShape();
            for (int i = 0; i < lst.Count; i++)
            {
                if (lst[i].IndexOf(param) > -1)
                {
                    ret = BSFace.GetBlendShapeWeight(i);
                    break;
                }
            }
            return ret;
        }
        public int getAvatarBlendShapeIndex(string name)
        {
            return BSFace.sharedMesh.GetBlendShapeIndex(name);
        }
        public void changeAvatarBlendShape(string param)
        {
            string[] prm = param.Split(',');
            int index = int.TryParse(prm[0], out index) ? index : 0;
            float value = float.TryParse(prm[1], out value) ? value : 0f;
            BSFace.SetBlendShapeWeight(index, value);
        }
        public void changeAvatarBlendShape(int index, float value)
        {
            BSFace.SetBlendShapeWeight(index, value);
        }
        public void changeAvatarBlendShapeByName(string param)
        {
            string[] prm = param.Split(',');
            string shapename = prm[0];
            float value = float.TryParse(prm[1], out value) ? value : 0f;
            int index = getAvatarBlendShapeIndex(shapename);
            if (index > -1)
            {
                BSFace.SetBlendShapeWeight(index, value);
            }
        }
        public void changeAvatarBlendShapeByName(string shapename, float value)
        {
            int index = getAvatarBlendShapeIndex(shapename);
            if (index > -1)
            {
                BSFace.SetBlendShapeWeight(index, value);
            }
        }




        //===============================================================================================================================
        //  Equip 

        public void SetEquipFlag(int flag)
        {
            equipType = flag;
        }
        public int GetEquipFlag()
        {
            return equipType;
        }
        public int GetEquipFlagFromOuter()
        {
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveIntVal(equipType);
#endif
            return equipType;
        }
        public List<AvatarEquipSaveClass> GetEquipmentInformation()
        {
            return equipDestinations.list;
        }
        public void GetEquipmentInformationFromOuter()
        {
            string js = JsonUtility.ToJson(equipDestinations);
#if !UNITY_EDITOR && UNITY_WEBGL
            ReceiveStringVal(js);
#endif
        }
        /// <summary>
        /// To apply equipment object position to destination body parts position
        /// </summary>
        /// <param name="parts"></param>
        /// <param name="equipment"></param>
        public void EquipPositioning(HumanBodyBones parts, NativeAnimationAvatar equipment)
        {
            Transform dest = this.gameObject.GetComponent<Animator>().GetBoneTransform(parts);
            equipment.avatar.transform.position = dest.position;
        }

        /// <summary>
        /// To equip other item object
        /// (*) if already equped, nothing function
        /// vi devas sxargi position kaj rotation antaux cxi tiu funkcio
        /// </summary>
        /// <param name="parts"></param>
        /// <param name="equipment">animation avatar</param>
        public void EquipObject(HumanBodyBones parts, NativeAnimationAvatar equipment)
        {
            Transform dest = this.gameObject.GetComponent<Animator>().GetBoneTransform(parts);
            //ManageAnimation manim = GameObject.Find("AnimateArea").GetComponent<ManageAnimation>();
            OperateLoadedBase olo = equipment.avatar.GetComponent<OperateLoadedBase>();
            OtherObjectDummyIK ooik = olo.relatedHandleParent.GetComponent<OtherObjectDummyIK>();

            int isHit = equipDestinations.list.FindIndex(match =>
            {
                if ((match.bodybonename == parts) && (match.equipitem == equipment.roleName)) return true;
                return false;
            });

            if (isHit == -1)
            {
                equipment.avatar.transform.SetParent(dest);
                //equipment.transform.position = dest.position;


                //---set up DummyIK
                ooik.isEquipping = true;
                ooik.equippedAvatar = this.gameObject;

                //---set up for animation
                //string[] roles = manim.GetRoleSpecifiedAvatar(equipment.name);
                AvatarEquipSaveClass ave = new AvatarEquipSaveClass();
                ave.bodybonename = parts;
                ave.equipitem = equipment.roleName;  //roles[0];
                ave.position = olo.GetPosition();
                ave.rotation = olo.GetRotation();
                equipDestinations.list.Add(ave);

                //---set up IK marker
                GameObject ikhandle = olo.relatedHandleParent;
                //ikhandle.transform.position = dest.position;
                ikhandle.SetActive(false);

                //---set up object self
                olo.SetColliderAvailable(false);
                equipment.avatar.layer = LayerMask.NameToLayer("Default");

            }
        }

        /// <summary>
        /// To exchange before equipment and after equipment.
        /// </summary>
        /// <param name="parts"></param>
        /// <param name="equipment">animation avatar</param>
        public void EquipExchange(HumanBodyBones parts, NativeAnimationAvatar equipment)
        {
            int isHit = equipDestinations.list.FindIndex(match =>
            {
                if ((match.bodybonename == parts) && (match.equipitem == equipment.roleName)) return true;
                return false;
            });

            if (isHit > -1)
            {
                UnequipObject(parts, equipment.roleName);
            }

            EquipObject(parts, equipment);
        }

        /// <summary>
        /// To equip an object to body part of specified NAME
        /// </summary>
        /// <param name="parts"></param>
        /// <param name="equipment">animation avatar</param>
        public void EquipObjectByName(string parts, NativeAnimationAvatar equipment)
        {
            foreach (HumanBodyBones value in Enum.GetValues(typeof(HumanBodyBones)))
            {
                string name = Enum.GetName(typeof(HumanBodyBones), value);
                if (parts == name)
                {
                    EquipObject(value, equipment);
                    break;
                }
            }
        }
        
        /// <summary>
        /// 
        /// </summary>
        /// <param name="param">CSV-string: [0] - HumanBodyBones position index, [1] - role name, [2] - isquip flag(</param>
        public void EquipObjectFromOuter(string param)
        {
            string[] prm = param.Split(',');
            int index = int.TryParse(prm[0], out index) ? index : 0;
            string name = prm[1];
            string isequip = prm[2];

            NativeAnimationAvatar nav = manim.GetCastInProject(name);
            if (nav != null)
            {
                if (isequip == "1")
                {
                    EquipExchange((HumanBodyBones)index, nav);
                }
                else
                { //---effectively NOT USE
                    EquipPositioning((HumanBodyBones)index, nav);
                }
            }
            /*
            GameObject pt = GameObject.Find(name);
            if (pt != null)
            {
                if (isequip == "1")
                {
                    //EquipObject((HumanBodyBones)index, pt);
                    EquipExchange((HumanBodyBones)index, pt);
                }
                else
                {
                    EquipPositioning((HumanBodyBones)index, pt);
                }
            }
            */
            
        }

        /// <summary>
        /// Un-equip the object
        /// </summary>
        /// <param name="parts">body bone name</param>
        /// <param name="equipmentName">role name of the object</param>
        public void UnequipObject(HumanBodyBones parts, string equipmentName)
        {
            //ManageAnimation manim = GameObject.Find("AnimateArea").GetComponent<ManageAnimation>();

            Transform dest = this.gameObject.GetComponent<Animator>().GetBoneTransform(parts);

            AvatarEquipSaveClass aes =  equipDestinations.list.Find(match =>
            {
                if ((match.bodybonename == parts) && (match.equipitem == equipmentName)) return true;
                return false;
            });
            if (aes != null)
            {
                NativeAnimationAvatar naa =  manim.GetCastInProject(aes.equipitem);
                GameObject equip = naa.avatar; // dest.Find(equipmentName).gameObject;
                if (equip)
                {
                    OperateLoadedBase olb = equip.GetComponent<OperateLoadedBase>();
                    GameObject ikhandle = olb.relatedHandleParent;

                    equip.transform.SetParent(GameObject.Find("View Body").transform);
                    equip.layer = LayerMask.NameToLayer("Player");
                    olb.SetColliderAvailable(true);

                    if (ikhandle != null)
                    {
                        OtherObjectDummyIK ooik = ikhandle.GetComponent<OtherObjectDummyIK>();
                        ooik.isEquipping = false;
                        ooik.equippedAvatar = null;

                        //---recover transform of ik-marker to effective object transform.
                        //   because transform of ik-market and effective object don't link during equipment.
                        ikhandle.transform.position = equip.transform.position;
                        ikhandle.transform.rotation = equip.transform.rotation;
                        ikhandle.SetActive(true);

                        equipDestinations.list.Remove(aes);
                    }
                }
            }
            
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="param">csv string: [0] body bone name, [1] - role name</param>
        public void UnequipObjectFromOuter(string param)
        {
            string[] prm = param.Split(',');
            int index = int.TryParse(prm[0], out index) ? index : 0;
            string name = prm[1];

            UnequipObject((HumanBodyBones)index, name);
        }
        /*
        public int GetFixMoving()
        {
            return isFixMoving ? 1 : 0;
        }
        public void SetFixMoving(bool flag)
        {
            isFixMoving = flag;
            if (flag)
            {
                transform.gameObject.GetComponent<CapsuleCollider>().enabled = false;
                relatedHandleParent.SetActive(false);
            }
            else
            {
                transform.gameObject.GetComponent<CapsuleCollider>().enabled = true;
                relatedHandleParent.SetActive(true);
            }
        }
        public void SetFixMovingFromOuter(string param)
        {
            SetFixMoving(param == "1" ? true : false);
        }
        */

        /// <summary>
        /// To recover the IK transform(position, rotation) by HumanBodyBones of avatar self.
        /// </summary>
        public void RecoverIKTransform()
        {
            Animator animator = GetComponent<Animator>();
            int childCount = relatedHandleParent.transform.childCount;

            //---Head <= Head
            Transform head = relatedHandleParent.transform.Find("Head");
            head.position = animator.GetBoneTransform(HumanBodyBones.Head).transform.position;
            head.rotation = animator.GetBoneTransform(HumanBodyBones.Head).transform.rotation;

        }
        public override void EnableIK(bool flag)
        {
            BipedIK bik = gameObject.TryGetComponent<BipedIK>(out bik) ? bik : null;
            CCDIK cik = gameObject.TryGetComponent<CCDIK>(out cik) ? cik : null;
            LeftHandPoseController lhand = gameObject.TryGetComponent<LeftHandPoseController>(out lhand) ? lhand : null;
            RightHandPoseController rhand = gameObject.TryGetComponent<RightHandPoseController>(out rhand) ? rhand : null;

            if (flag)
            {
                if (rhand != null) rhand.enabled = flag;
                if (lhand != null) lhand.enabled = flag;
                if (bik != null) bik.enabled = flag;
                if (cik != null) cik.enabled = flag;
            }
            else
            {
                if (cik != null) cik.enabled = flag;
                if (bik != null) bik.enabled = flag;
                if (lhand != null) lhand.enabled = flag;
                if (rhand != null) rhand.enabled = flag;
            }
            
        }
    }

}
